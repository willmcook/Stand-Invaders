<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Space Invaders ‚Äì Custom Ship</title>
  <style>
    :root{ --bg:#0b0f1a; --fg:#e6eaf2; --accent:#6ae3ff; --accent2:#a285ff; --danger:#ff6a6a; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 50% -20%,#1a2340 0%, var(--bg) 55%);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
    .wrap{max-width:960px;margin:0 auto;padding:16px;display:flex;flex-direction:column;gap:12px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-weight:700;font-size:clamp(20px,4vw,28px);margin:0;letter-spacing:0.5px}
    .hud{display:flex;gap:16px;flex-wrap:wrap;align-items:center}
    .pill{padding:6px 10px;border-radius:999px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.09)}
    #game{position:relative;border-radius:16px;overflow:hidden;border:1px solid rgba(255,255,255,0.08);box-shadow:0 20px 40px rgba(0,0,0,.4)}
    canvas{display:block;width:100%;height:auto;background:linear-gradient(#05070d,#0b0f1a)}

    .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg, rgba(9,12,22,.88), rgba(9,12,22,.88));backdrop-filter: blur(4px);text-align:center;padding:24px}
    .card{max-width:720px}
    .title{font-size:clamp(22px,5vw,36px);font-weight:800;margin:0 0 8px}
    .muted{opacity:.85}
    .btns{margin-top:16px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
    button{appearance:none;border:none;border-radius:12px;padding:10px 14px;font-weight:700;color:#0b0f1a;background:var(--accent);cursor:pointer;box-shadow:0 10px 22px rgba(106,227,255,.25)}
    button.secondary{background:transparent;color:var(--fg);border:1px solid rgba(255,255,255,.18)}

    /* Mobile controls */
    .touch-controls{position:absolute;inset:0;pointer-events:none}
    .tc-row{position:absolute;bottom:10px;left:0;right:0;display:flex;justify-content:space-between;padding:0 10px;gap:10px}
    .tc-btn{pointer-events:auto;touch-action:manipulation;user-select:none;width:30%;height:64px;border-radius:14px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.1);display:flex;align-items:center;justify-content:center;font-weight:800;color:#d7e4ff}
    .tc-btn.fire{width:36%}

    .legend{font-size:13px;opacity:.8}
    code.k{padding:2px 6px;border-radius:6px;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12)}

    footer{opacity:.8;font-size:12px;text-align:center;margin:8px 0 26px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üëæ Space Invaders ‚Äî Custom Ship</h1>
      <div class="hud">
        <div class="pill" id="scorePill">Score: <strong id="score">0</strong></div>
        <div class="pill">Lives: <strong id="lives">3</strong></div>
        <div class="pill legend">Move: <code class="k">‚Üê</code>/<code class="k">‚Üí</code> ‚Ä¢ Shoot: <code class="k">Space</code> ‚Ä¢ Pause: <code class="k">P</code></div>
      </div>
    </header>

    <div id="game">
      <canvas id="c" width="960" height="640"></canvas>

      <!-- Start / Pause overlays -->
      <div class="overlay" id="startOverlay">
        <div class="card">
          <h2 class="title">Defend the galaxy ‚≠ê</h2>
          <p class="muted">Use your custom ship to blast waves of invaders. Clear the fleet to win the level. If enemies reach the ground, it's game over!</p>
          <p class="legend">Keyboard: <code class="k">‚Üê</code>/<code class="k">‚Üí</code> to move ‚Ä¢ <code class="k">Space</code> to shoot ‚Ä¢ <code class="k">P</code> to pause</p>
          <div class="btns">
            <button id="btnStart">Start</button>
            <button class="secondary" id="btnMute">Toggle Sound</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="pauseOverlay" style="display:none">
        <div class="card">
          <h2 class="title">Paused ‚è∏Ô∏è</h2>
          <p class="muted">Press <code class="k">P</code> to resume.</p>
          <div class="btns">
            <button id="btnResume">Resume</button>
            <button class="secondary" id="btnRestart">Restart</button>
          </div>
        </div>
      </div>

      <div class="overlay" id="gameOverOverlay" style="display:none">
        <div class="card">
          <h2 class="title" id="gameOverTitle">Game Over</h2>
          <p class="muted" id="finalScore"></p>
          <div class="btns">
            <button id="btnPlayAgain">Play again</button>
          </div>
        </div>
      </div>

      <!-- Touch controls (auto show on small screens) -->
      <div class="touch-controls" id="touchControls" style="display:none">
        <div class="tc-row">
          <div class="tc-btn" id="btnLeft">‚óÄÔ∏é</div>
          <div class="tc-btn fire" id="btnFire">‚óè</div>
          <div class="tc-btn" id="btnRight">‚ñ∂Ô∏é</div>
        </div>
      </div>
    </div>

    <footer>
      Built for you with your ship image. Have fun and tweak values in the code to change difficulty, speed, and layouts!
    </footer>
  </div>

  <script>
    // ===== Canvas Setup with HiDPI scaling =====
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    function fitCanvas(){
      const maxW = 960, maxH = 640; // design size
      const ratio = maxW/maxH;
      const w = Math.min(document.getElementById('game').clientWidth, maxW);
      const h = Math.min(Math.round(w/ratio), maxH);
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width = w+"px";
      canvas.style.height = h+"px";
      canvas.width = Math.round(w*dpr);
      canvas.height = Math.round(h*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
    }
    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // ===== Game State =====
    const state = {
      running:false,
      paused:false,
      level:1,
      lives:3,
      score:0,
      keys:{},
      mute:false,
      playerInvuln:0, // seconds of invulnerability after hit
    };

    // HUD elems
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');

    // Overlays
    const startOverlay = document.getElementById('startOverlay');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const finalScore = document.getElementById('finalScore');
    const gameOverTitle = document.getElementById('gameOverTitle');

    // Buttons
    document.getElementById('btnStart').onclick = startGame;
    document.getElementById('btnMute').onclick = () => state.mute = !state.mute;
    document.getElementById('btnResume').onclick = togglePause;
    document.getElementById('btnRestart').onclick = restartGame;
    document.getElementById('btnPlayAgain').onclick = restartGame;

    // ===== Assets =====
    const playerImg = new Image();
    playerImg.src = 'https://i.postimg.cc/KY8PWWyc/1.png'; // your custom ship
    playerImg.crossOrigin = 'anonymous';

    // Invader sprites (randomized per enemy)
    const invaderSrcs = [
      'https://i.postimg.cc/8CzRYYVc/2.jpg',
      'https://i.postimg.cc/Zq58QQhR/3.png',
      'https://i.postimg.cc/7LZ3RRyL/4.png',
      'https://i.postimg.cc/cJLRzzNf/5.jpg',
      'https://i.postimg.cc/CKxG22VZ/6.jpg'
    ];
    const invaderImgs = invaderSrcs.map(src=>{ const img=new Image(); img.src=src; img.crossOrigin='anonymous'; return img; });

    // ===== Audio =====
    function buzz(freq, dur=0.08, type='square', vol=0.05){
      if(state.mute) return; 
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if(!AudioCtx) return;
      buzz.ctx = buzz.ctx || new AudioCtx();
      const ctxA = buzz.ctx;
      const o = ctxA.createOscillator();
      const g = ctxA.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value=vol; o.connect(g); g.connect(ctxA.destination);
      o.start();
      setTimeout(()=>{o.stop()}, dur*1000);
    }

    // ===== Helpers =====
    function fitContain(iw, ih, maxW, maxH){
      const s = Math.min(maxW/iw, maxH/ih);
      return {w: Math.max(1, Math.floor(iw*s)), h: Math.max(1, Math.floor(ih*s))};
    }
    function aabb(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }

    // More aggressive enemy fire ramp per level
    function cooldownRangeForLevel(level){
      const baseMin=0.9, baseMax=1.4; // seconds
      const dec = 0.12*level; // faster ramp
      const min = Math.max(0.12, baseMin - dec);
      const max = Math.max(min+0.05, baseMax - dec*0.9);
      return [min, max];
    }

    // ===== Entities =====
    class Player{
      constructor(){
        this.w = 64; this.h = 52; this.x = canvas.width/2; this.y = (canvas.height/ (window.devicePixelRatio||1)) - 90;
        this.speed = 400; // px/sec
        this.cooldown = 0;
      }
      update(dt){
        const left = state.keys['ArrowLeft']||state.keys['a']||state.keys['A'];
        const right= state.keys['ArrowRight']||state.keys['d']||state.keys['D'];
        if(left) this.x -= this.speed*dt;
        if(right) this.x += this.speed*dt;
        // clamp
        this.x = Math.max(this.w/2+8, Math.min((canvas.width/(window.devicePixelRatio||1)) - this.w/2 - 8, this.x));
        if(this.cooldown>0) this.cooldown -= dt;
        if(state.playerInvuln>0) state.playerInvuln -= dt;
      }
      draw(){
        const x = this.x - this.w/2, y = this.y - this.h/2;
        if(playerImg.complete && playerImg.naturalWidth){
          const fit = fitContain(playerImg.naturalWidth, playerImg.naturalHeight, this.w, this.h);
          const dx = Math.floor(this.x - fit.w/2);
          const dy = Math.floor(this.y - fit.h/2);
          if(state.playerInvuln>0){ ctx.save(); ctx.globalAlpha = 0.55; ctx.drawImage(playerImg, dx, dy, fit.w, fit.h); ctx.restore(); }
          else { ctx.drawImage(playerImg, dx, dy, fit.w, fit.h); }
        }else{ // fallback triangle
          ctx.fillStyle = '#7cc9ff';
          ctx.beginPath(); ctx.moveTo(this.x, y); ctx.lineTo(x, y+this.h); ctx.lineTo(x+this.w, y+this.h); ctx.closePath(); ctx.fill();
        }
      }
      shoot(){
        if(this.cooldown>0) return;
        bullets.push(new Bullet(this.x, this.y-30, -800));
        this.cooldown = 0.25;
        buzz(520, .07, 'square', .04);
      }
      getAABB(){ return {x:this.x-this.w/2,y:this.y-this.h/2,w:this.w,h:this.h}; }
    }

    class Bullet{
      constructor(x,y,vy){ this.x=x; this.y=y; this.vy=vy; this.r=4; }
      update(dt){ this.y += this.vy*dt; }
      draw(){ ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fillStyle = '#a7d9ff'; ctx.fill(); }
      getAABB(){ return {x:this.x-this.r,y:this.y-this.r,w:this.r*2,h:this.r*2}; }
    }

    class EnemyBullet{
      constructor(x,y,vy){ this.x=x; this.y=y; this.vy=vy; this.r=3; }
      update(dt){ this.y += this.vy*dt; }
      draw(){ ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fillStyle = '#ffb1b1'; ctx.fill(); }
      getAABB(){ return {x:this.x-this.r,y:this.y-this.r,w:this.r*2,h:this.r*2}; }
    }

    class Enemy{
      constructor(x,y,w=56,h=44,row=0){
        this.x=x; this.y=y; this.w=w; this.h=h; this.row=row; this.alive=true;
        this.img = invaderImgs[Math.floor(Math.random()*invaderImgs.length)] || null;
      }
      draw(){
        if(this.img && this.img.complete && this.img.naturalWidth){
          const fit = fitContain(this.img.naturalWidth, this.img.naturalHeight, this.w, this.h);
          const dx = Math.floor(this.x - fit.w/2);
          const dy = Math.floor(this.y - fit.h/2);
          ctx.drawImage(this.img, dx, dy, fit.w, fit.h);
        } else {
          ctx.save();
          ctx.translate(this.x-this.w/2,this.y-this.h/2);
          const g = ctx.createLinearGradient(0,0,this.w,this.h); g.addColorStop(0,'#b693ff'); g.addColorStop(1,'#6ae3ff');
          ctx.fillStyle=g; ctx.fillRect(0,0,this.w,this.h);
          ctx.fillStyle='rgba(0,0,0,.12)'; ctx.fillRect(6,6,this.w-12,this.h-12);
          ctx.restore();
        }
      }
      getAABB(){ return {x:this.x-this.w/2,y:this.y-this.h/2,w:this.w,h:this.h}; }
    }

    // ===== Game Setup =====
    let player, bullets, enemies, enemyDir, enemySpeed, dropDistance, lastTime;
    let enemyBullets, enemyFireCooldown;

    function setupLevel(lvl=1){
      player = new Player();
      bullets = [];
      enemyBullets = [];
      enemies = [];
      enemyDir = 1; // 1 -> right, -1 -> left
      enemySpeed = 50 + (lvl-1)*12; // base speed increases with level
      dropDistance = 24; // drop when hitting side
      const [minCd, maxCd] = cooldownRangeForLevel(lvl);
      enemyFireCooldown = minCd + Math.random()*(maxCd-minCd);

      const cols = 10, rows = 5; // grid
      const gapX = 18, gapY = 16;
      const startX = 80, startY = 80;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const x = startX + c*(44+gapX);
          const y = startY + r*(30+gapY);
          enemies.push(new Enemy(x,y,56,44,r));
        }
      }
    }

    function startGame(){
      state.running=true; state.paused=false; state.level=1; state.score=0; state.lives=3; state.playerInvuln=0;
      scoreEl.textContent=state.score; livesEl.textContent=state.lives;
      setupLevel(1);
      lastTime = performance.now();
      startOverlay.style.display='none';
      gameOverOverlay.style.display='none';
      loop(lastTime);
    }

    function restartGame(){ startGame(); }

    function togglePause(){
      if(!state.running) return;
      state.paused = !state.paused;
      pauseOverlay.style.display = state.paused ? 'flex' : 'none';
      if(!state.paused){ lastTime = performance.now(); loop(lastTime); }
    }

    const touchControls = document.getElementById('touchControls');
    function updateTouchVisibility(){ touchControls.style.display = window.innerWidth < 720 ? 'block' : 'none'; }
    updateTouchVisibility();
    window.addEventListener('resize', updateTouchVisibility);

    document.addEventListener('keydown', (e)=>{
      if(e.code==='Space') e.preventDefault();
      state.keys[e.key]=true;
      if(e.key==='p' || e.key==='P') togglePause();
      if(e.code==='Space' && state.running && !state.paused) player.shoot();
    });
    document.addEventListener('keyup', (e)=>{ state.keys[e.key]=false; });

    const btnLeft = document.getElementById('btnLeft');
    const btnRight= document.getElementById('btnRight');
    const btnFire = document.getElementById('btnFire');
    const hold = (el, key) => {
      let on=false; const down=()=>{on=true; state.keys[key]=true}; const up=()=>{on=false; state.keys[key]=false};
      ['touchstart','mousedown'].forEach(ev=>el.addEventListener(ev, down));
      ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>el.addEventListener(ev, up));
    };
    hold(btnLeft,'ArrowLeft'); hold(btnRight,'ArrowRight');
    ['touchstart','mousedown'].forEach(ev=>btnFire.addEventListener(ev, ()=>player && player.shoot()));

    function drawStars(){
      const w = canvas.width/(window.devicePixelRatio||1), h = canvas.height/(window.devicePixelRatio||1);
      ctx.fillStyle = '#0b0f1a'; ctx.fillRect(0,0,w,h);
      for(let i=0;i<120;i++){
        const x = (Math.sin(i*12.9898+time*0.001)*43758.5453 % 1 + 1)%1 * w;
        const y = (Math.cos(i*78.233+time*0.0015)*12345.6789 % 1 + 1)%1 * h;
        const r = (i%3)+1; ctx.globalAlpha = 0.25 + (i%5)*0.12; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fillStyle='#ffffff'; ctx.fill(); ctx.globalAlpha=1;
      }
    }

    // choose a shooter among bottom-most alive in each column
    function chooseShooter(){
      const buckets = new Map();
      enemies.forEach(en=>{
        if(!en.alive) return;
        const key = Math.round(en.x/50); // rough column bucket
        const cur = buckets.get(key);
        if(!cur || en.y>cur.y) buckets.set(key, en);
      });
      const candidates = Array.from(buckets.values());
      if(candidates.length===0) return null;
      return candidates[Math.floor(Math.random()*candidates.length)];
    }

    // ===== Loop =====
    let time=0;
    function loop(t){
      if(!state.running) return;
      if(state.paused) return;
      const dt = Math.min(0.033, (t - lastTime)/1000); lastTime = t; time += dt*1000;

      // Update
      player.update(dt);
      bullets.forEach(b=>b.update(dt));
      enemyBullets.forEach(b=>b.update(dt));
      bullets = bullets.filter(b=>b.y>-20 && b.y < canvas.height/(window.devicePixelRatio||1)+20);
      enemyBullets = enemyBullets.filter(b=>b.y>-20 && b.y < canvas.height/(window.devicePixelRatio||1)+20);

      // Enemy fleet movement
      let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
      enemies.forEach(en=>{ if(!en.alive) return; minX=Math.min(minX, en.x-en.w/2); maxX=Math.max(maxX, en.x+en.w/2); maxY=Math.max(maxY, en.y+en.h/2); });
      const W = canvas.width/(window.devicePixelRatio||1);
      if(maxX>=W-10 || minX<=10){ enemyDir *= -1; enemies.forEach(en=>en.y += dropDistance); enemySpeed *= 1.06; buzz(220,.06,'sawtooth',.02); }
      enemies.forEach(en=>{ if(en.alive){ en.x += enemyDir*enemySpeed*dt; }});

      // Enemy firing logic (ramped)
      enemyFireCooldown -= dt;
      if(enemyFireCooldown<=0){
        const shooter = chooseShooter();
        if(shooter){
          const speed = 240 + state.level*35; // faster with level
          enemyBullets.push(new EnemyBullet(shooter.x, shooter.y+shooter.h/2+6, speed));
          // chance of a second shot at higher levels
          if(state.level>=3 && Math.random() < Math.min(0.1*state.level, 0.5)){
            const shooter2 = chooseShooter();
            if(shooter2){ enemyBullets.push(new EnemyBullet(shooter2.x, shooter2.y+shooter2.h/2+6, speed*1.05)); }
          }
          buzz(180,.06,'sine',.03);
        }
        const [minCd, maxCd] = cooldownRangeForLevel(state.level);
        enemyFireCooldown = minCd + Math.random()*(maxCd-minCd);
      }

      // Collisions: player bullets vs enemies
      for(const b of bullets){
        const ba = b.getAABB();
        for(const en of enemies){ if(!en.alive) continue; if(aabb(ba, en.getAABB())){ en.alive=false; b.y = -9999; state.score += 10 + (4-en.row)*2; scoreEl.textContent = state.score; buzz(360,.06,'triangle',.035); break; }}
      }

      // Collisions: enemy bullets vs player
      if(state.playerInvuln<=0){
        const pa = player.getAABB();
        for(const eb of enemyBullets){ if(aabb(eb.getAABB(), pa)){ eb.y = 99999; onPlayerHit(); break; } }
      }

      // Loss condition: enemies reached ground => INSTANT GAME OVER
      const groundY = (canvas.height/(window.devicePixelRatio||1)) - 60;
      let reachedGround = enemies.some(en=>en.alive && en.y+en.h/2 >= groundY);
      if(reachedGround){ endGame(false); return; }
      // Also end life if an enemy collides with the player sprite
      let hitPlayer = enemies.some(en=>en.alive && aabb(en.getAABB(), player.getAABB()));
      if(hitPlayer){ onPlayerHit(); }

      // Win condition: all dead
      if(enemies.every(e=>!e.alive)){
        state.level += 1; buzz(660,.2,'square',.05); setupLevel(state.level);
      }

      // Draw
      drawStars();
      player.draw();
      bullets.forEach(b=>b.draw());
      enemies.forEach(en=>{ if(en.alive) en.draw(); });
      enemyBullets.forEach(b=>b.draw());

      requestAnimationFrame(loop);
    }

    function onPlayerHit(){
      state.lives -= 1; livesEl.textContent = state.lives; buzz(120,.15,'sawtooth',.05);
      if(state.lives<=0){ return endGame(false); }
      state.playerInvuln = 1.2; // brief grace period
      enemyBullets.length = 0; // clear on hit to avoid chain hits
    }

    function endGame(won){
      state.running=false; state.paused=false;
      finalScore.textContent = `Score: ${state.score}`;
      gameOverTitle.textContent = won ? 'You Win! üéâ' : 'Game Over üíÄ';
      gameOverOverlay.style.display = 'flex';
    }

    // ===== SELF-TESTS (non-intrusive) =====
    (function runSelfTests(){
      const tests = [];
      const assert = (name, cond) => tests.push({name, pass: !!cond});
      try {
        // Test 1: Enemy.getAABB exists and returns expected shape
        const e = new Enemy(100,100,50,40,0);
        const box = e.getAABB();
        assert('Enemy.getAABB exists', typeof e.getAABB === 'function');
        assert('Enemy.getAABB dimensions', Math.abs(box.w-50)<1e-6 && Math.abs(box.h-40)<1e-6);

        // Test 2: Bullet AABB
        const b = new Bullet(10,10,-100);
        const bb = b.getAABB();
        assert('Bullet.getAABB returns square of diameter 8', bb.w===8 && bb.h===8);

        // Test 3: aabb collision basic sanity
        assert('aabb collision true when overlapping', aabb({x:0,y:0,w:10,h:10},{x:5,y:5,w:10,h:10})===true);
        assert('aabb collision false when apart', aabb({x:0,y:0,w:10,h:10},{x:20,y:20,w:10,h:10})===false);

        // Test 4: Image list present
        assert('invader images loaded list length', Array.isArray(invaderImgs) && invaderImgs.length===5);

        // Test 5: fitContain preserves aspect ratio
        const fit1 = fitContain(200,100,64,52); // 2:1 image into 64x52 => 64x32
        assert('fitContain example1', fit1.w===64 && fit1.h===32);
        const fit2 = fitContain(100,200,64,52); // 1:2 => 26x52
        assert('fitContain example2', fit2.w===26 && fit2.h===52);

        // Test 6: EnemyBullet AABB
        const eb = new EnemyBullet(0,0,100);
        const ebox = eb.getAABB();
        assert('EnemyBullet.getAABB size', ebox.w===6 && ebox.h===6);

        // Test 7: cooldownRange ramps down with level and clamps
        const [mn1,mx1] = cooldownRangeForLevel(1);
        const [mn5,mx5] = cooldownRangeForLevel(5);
        assert('cooldown min decreases by level', mn5 <= mn1 && mn5 >= 0.12);
        assert('cooldown max >= min+0.05', mx5 >= mn5 + 0.05);
      } catch(err){
        console.error('[SelfTests] Exception', err);
      } finally {
        const passed = tests.filter(t=>t.pass).length;
        const failed = tests.length - passed;
        console.log('%c[SelfTests] '+passed+' passed, '+failed+' failed', 'font-weight:bold');
        tests.forEach(t=>console.log(' -', t.pass?'‚úÖ':'‚ùå', t.name));
      }
    })();

    // Start on Enter or Space
    window.addEventListener('keydown', (e)=>{
      if(startOverlay.style.display!=='none' && (e.key==='Enter' || e.code==='Space')) startGame();
    });
  </script>
</body>
</html>
